## Part 1. Установка ОС
* Устанавливаем Ubuntu 20.04 Server LTS без графического интерфейса. Для виртуализации используется команда VirtualBox.
* Проверяем версию системы командой `cat /etc/issue`:

![ubuntu version](/images/part1.1.png "Версия системы")

## Part 2. Создание пользователя

* Создадим нового пользователя командой `sudo adduser (username)`:

![create new user](/images/part2.1.png "Добавление нового пользователя")

* Добавим его в группу adm командой `sudo usermod -aG (groupname) (username)`. Перейдем на нового пользователя командой `su (username)` и проверим, что он находится в группе командой `groups`:

![add to adm](/images/part2.2.png "Добавление пользователя в группу adm")

* Вывод команды `cat /etc/passwd` с новым пользователем: 

![new user](/images/part2.3.png "Новый пользователь")

## Part 3. Настройка сети ОС
* Изменим название машины на user-1 командой `sudo hostname (hostname)`, а также поменяем файл /etc/hostname командой `nano /etc/hostname`:

![new hostname](/images/part3.1.png "Новое имя машины")

* Изменим временную зону на зону, соответствующую Москве командой `sudo timedatectl set-timezone (timezone)`. Проверим временную зону командой `timedatectl`: 

![new timezone](/images/part3.2.png "Изменение временной зоны")

* Для того, чтобы вывести сетевые интерфейсы воспользуемся командой `ip link`:

![ip link](/images/part3.3.png "Сетевые интерфейсы")
> **Loopback** - канал коммуникации с одной конечной точкой. Любые сообщения, посылаемые на этот канал, немедленно принимаются тем же самым каналом. Любые сообщения, которые отправляются с этого интерфейса, но у которых адрес не Loopback Interface, отбрасываются. В компьютерах таким адресом loopback interface является адрес 127.0.0.1, он фиксированный и изменению не подлежит. На Unix-like системах loopback interface называется lo или lo0.

* Для работы с DHCP  (Dynamic Host Configuration Protocol) используем инструмент dhclient.
> **DHCP** (Dynamic Host Configuration Protocol — протокол динамической настройки узла) — сетевой протокол, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети TCP/IP. 

* Сначала сбросим существующий IP-адрес командой `sudo dhclient -r enp0s3`. Затем получим IP-адрес командой `sudo dhclient -v enp0s3`. Чтобы опеределить текущий IP-адрес устройства используем команду `ip a`. IP-адрес выводится на строке inet: 10.0.2.15.

![ip-adress](/images/part3.4.png "IP-адрес")

* Чтобы узнать внешний IP-адрес воспользуемся командой `curl ident.me`:

![ident.me](/images/part3.5.png "Внешний IP-адрес")

* Чтобы получить IP-адрес по умолчанию используем команду `ip route | grep default`:

![default ip](/images/part3.6.png "Внешний IP-адрес")

> **Внутренний (локальный) IP** — это IP-адрес, который выдается компьютеру в пределах внутренней локальной сети. Такой адрес не используется для выхода в сеть.
> **Внешний IP-адрес** вы получаете от вашего провайдера. Он может быть статическим и динамическим (меняется каждый раз когда вы подключаетесь к сети).

* Начиная с Ubuntu 17.10 и более поздних версий, сетевое взаимодействие контролируется функцией Netplan. Файлы конфигурации для Netplan находятся в каталоге  /etc/netplan и написаны на языке YAML. Перейдем к единственному файлу в этом каталоге `sudo nano /etc/netplan/00-installer-config.yaml`.

* Установим значение «dhcp4» на "false", чтобы отключить протокол DHCP. Зададим статичные настройки  ip, gw, dns:

![static settings](/images/part3.7.png "Статичные настройки")

* Применяем настройки командой `sudo netplan apply`. Убеедимся, что настройки применились используя команду `ip a`:

![check settings](/images/part3.8.png "Проверка настроек")

* Хосты 1.1.1.1 и ya.ru пропингованы успешно: 
![ping hosts](/images/part3.9.png "Пинг хостов 1.1.1.1 и ya.ru")

## Part 4. Обновление ОС
* Для обновления выполняем команды `sudo apt-get update` и `sudo apt-get upgrade`. При повторном вызове команд видим, что обнвления отсутствуют: 

![OC update](/images/part4.1.png "Обновление системы")

## Part 5. Использование команды sudo
* Для того, чтобы разрешить новому пользователю выполнять команду sudo добавим его в группу sudo. Перейдем на нового пользователя и поменяем имя hostname. Также изменим содержимое файла /etc/hostname командой `sudo nano /etc/hostname`. После этого перезапускаем систему командой `sudo reboot`.

> Утилита **sudo** позволяет выполнить команду с правами администратора системы.

![add new user to sudo](/images/part5.1.png "Добавление нового пользователя в группу sudo. Изменение hostname")
![new hostname](/images/part5.2.png "Новое имя машины")

## Part 6. Установка и настройка службы времени
> Синхронизация времени производится посредством специального протокола передачи данных – **NTP (Network Time Protocol)**.
* В нашем случае синхронизация уже включена: 

![ntp](/images/part6.1.png "Установка и настройка службы времени")

* Если сервис выключен, включить его можно командой `sudo timedatectl set-ntp on`

## Part 7. Установка и использование текстовых редакторов
### VIM
* Создадим файл test_vim.txt командой `vim test_vim.txt`
* Для редактирования файла с текущей позиции нажимаем i. Вводим текст.

![vim1](/images/part7.1.png "Содержимое файла перед закрытием")

* Чтобы записать файлл и выйти нажимаем esc, :wq.

* Откроем файл на редактирование командой `vim test_vim.txt`. Для редактирования с конца строки нажимаем А. Меняем текст:

![vim2](/images/part7.2.png "Редактирование файла")

* Выйдем из файла без сохранения: esc -> :q!

* Еще раз откроем файл на редактирование командой `vim test_vim.txt`. Нажимаем / — перейти в режим поиска; Вводим искомое слово. Нажимаем Enter. Для того, чтобы перейти к следующему вхождению искомой строки нажмаем n. 

* Команда для замены `:[range]s/{pattern}/{string}/[flags] [count]`. Чтобы найти и заменить шаблон во всем файле, используем процентный символ % в качестве диапазона. Этот символ указывает диапазон от первой до последней строки файла. `:%s/shaquitt/21 Schhol 21`:

![vim3](/images/part7.3.png "Первоначальный текст")

![vim4](/images/part7.4.png "Текст после замены")

## NANO
* Создадим файл test_nano.txt командой `nano test_nano.txt`
* Редактируем файл. Для сохранения нажимаем ^X -> y -> enter.

![nano1](/images/part7.5.png "Содержимое файла перед закрытием")

* Откроем файл на редактирование командой `nano test_nano.txt`. Меняем текст. Выходим из файла без сохранения ^X -> n.

![nano2](/images/part7.6.png "Редактирование файла")

* Еще раз откроем файл на редактирование командой `nano test_nano.txt`. Для поиска используем комбинацию клавиш ^W и вводим искомое слово. Найдено одно совпадение: 

![nano3](/images/part7.7.png "Поиск")

* Для замены шаблона используем ^\, вводим слово, которое хотим заменить, а затем слово на которое хотим заменить. Для замены всех слов нажимаем А. 

![nano4](/images/part7.8.png "Замена")

## JOE 
* Устанавливаем joe командой `sudo apt install joe`:

![joe1](/images/part7.9.png "Установка joe")

* Создадим файл test_joe.txt командой `joe test_joe.txt`. Для выхода с сохранением испольуем ^K и Х.

![joe2](/images/part7.10.png "Содержимое файла перед закрытием")

* Откроем файл на редактирование командой `joe test_joe.txt`. Меняем текст. Выходим из файла без сохранения ^С -> y.

![joe3](/images/part7.11.png "Редактирование файла")


![joe4](/images/part7.12.png "Выход без сохранения")

* Еще раз откроем файл на редактирование командой `joe test_joe.txt`. Для поиска используем комбинацию клавиш ^KF и вводим искомое слово. 

![joe4](/images/part7.13.png "Поиск")

* Для замены найденных слов нажимаем R и вводим слово на которое хотим заменить: 

![joe5](/images/part7.14.png "Замена")

![joe6](/images/part7.15.png "Новое слово")

## Part 8. Установка и базовая настройка сервиса SSHD
> **SSH (Secure Shell)** — сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов). Шифрует весь трафик, включая и передаваемые пароли. 

* Для установки OpenSSH необходимо использовать команду `sudo apt install openssh-server`. Для установки SSH - `sudo apt-get install ssh`. Добавляем автозапуск команой `sudo systemctl enable ssh`.

Настройки демона хранятся в файле /etc/ssh/sshd_config. Открываем его командой `sudo nano /etc/ssh/sshd_config`. Меняем порт на 2022 и раскоментируем строку:

![sshd_config](/images/part8.1.png "Изменение порта")

Сохраняем файл и перезапускаем сервис командой `sudo service sshd restart`.

`ps -A | grep "ssh"` выведет все процессы с вхождениями ssh: 

![ps](/images/part8.2.png "Наличие процееса sshd")

> Команда ps выводит список текущих процессов на вашем сервере в виде таблицы, с которой можно удобно работать: сортировать, изменять количество колонок и др.
>> * **-A, -e, (a)** - выбрать все процессы;
>> * **-a** - выбрать все процессы, кроме фоновых;
>> * **-d, (g)** - выбрать все процессы, даже фоновые, кроме процессов сессий;
>> * **-N** - выбрать все процессы кроме указанных;
>> * **-С** - выбирать процессы по имени команды;
>> * **-G** - выбрать процессы по ID группы;
>> * **-p, (p)** - выбрать процессы PID;
>> * **--ppid** - выбрать процессы по PID родительского процесса;
>> * **-s** - выбрать процессы по ID сессии;
>> * **-t, (t)** - выбрать процессы по tty;
>> * **-u, (U)** - выбрать процессы пользователя.

*  Вывод команды `netstat -tan`: 

![netstat -tan](/images/part8.3.png "Вывод команды netstat -tan")

> Команда netstat показывает содержимое различных структур данных, связанных с активными сетевыми соединениями. 
>> * **-t** - TCP порты
>> * **-a** - все порты
>> * **-n** - вывод значений в цифровом формате. Команда покажет IP-адрес вместо хоста, номер порта вместо имени порта, UID вместо имени пользователя.
> Значения столбцов:
> * **Recv-Q** - количество полученных пакетов в ***очереди***.
> * **Send-Q** - количество отправленных пакетов в ***очереди***.
> * **Local Address:Port** – Адрес локальной машины и порта.
> * **Peer Address:Port** – Адрес удаленного компьютера и порта.
> * **State** - состояние сокета. Общие состояния: ESTAB (установлено), UNCONN (отключено), LISTEN (прослушивание), CLOSE-WAIT и SYN-SENT.

> Если в качестве адреса отображается 0.0.0.0 , то это означает - "любой адрес", т. е в соединении могут использоваться все IP-адреса существующие на данном компьютере.

## Part 9. Установка и использование утилит top, htop
### TOP
> Команда top показывает запущенные в Linux процессы программ и служб, данные о потреблении системных ресурсов и позволяет искать, останавливать и управлять процессами.

* Вывод команды top:

![top](/images/part9.1.png "Вывод команды top")

* uptime = 2.36 (2 часа 36 минут);
* Количество авторизованных пользователей = 1;
* Общая загрузка системы = 0,11, 0,28, 0,19 (среднее за 1, 5, 15 минут);
* Oбщее количество процессов = 104;
* Загрузка cpu = 0,0 us, 0,0 sy, 0,0 ni, 100,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st;
> * us: процент времени, когда ЦПУ был загружен и которое было затрачено на user space (созданные/запущенные пользователем процессы)
> * sy: процент времени, когда ЦПУ был загружен и которое было затрачено на на kernel (системные процессы)
> * ni: процент времени, когда ЦПУ был загружен и которое было затрачено на приоритезированные пользовательские процессы (системные процессы)
> * id: процент времени, когда ЦПУ не был загружен
> * wa: процент времени, когда ЦПУ ожидал отклика от устройств ввода - вывода (к примеру, ожидание завершения записи информации на диск)
> * hi: процент времени, когда ЦПУ получал аппаратные прерывания (например, от сетевого адаптера)
> * si: процент времени, когда ЦПУ получал программные прерывания (например, от какого-то приложения адаптера)
> * st: сколько процентов было "украдено" виртуальной машиной - в случае, если гипервизору понадобилось увеличить собственные ресурсы
* Загрузка памяти = MiB Mem: 1983,2 total, 1329,8 free, 166,8 used, 486,5 buff/cache, MiB Swap: 0,0 total, 0,0 free, 0,0 used, 1662,8 avail Mem.
> SWAP — это дополнительная память, размещаемая на логическом разделе жесткого диска физического носителя, которая может быть использована в случае исчерпания гарантированного объема оперативной памяти. Обычно операционная система использует SWAP для менее активных приложений, нежели гарантированную память.
* Pid процесса, занимающего больше всего памяти = 675;
> Чтобы выполнить в top сортировку по памяти (%MEM), достаточно ввести Shift+M.

![most mem](/images/part9.2.png "Процесс, занимающий больше всего памяти")
* Pid процесса, занимающего больше всего процессорного времени = 563;
> Изначальная сортировка при открытии top показывает сначала процессы, занимающие больше всего процессорного времени.

![most time](/images/part9.3.png "Процесс, занимающий больше всего процессорного времени")

* Для выхода из top используем q.

### HTOP
* Для сортировки нажимаем fn+F6 и выбираем нужный столбец.
* Сортировка по PID: 

![pid sort](/images/part9.4.png "Сортировка по PID")

* Сортировка по PERCENT_CPU: 

![PERCENT_CPU sort](/images/part9.5.png "Сортировка по PERCENT_CPU")

* Сортировка по PERCENT_MEM: 

![PERCENT_MEM sort](/images/part9.6.png "Сортировка по PERCENT_MEM")

* Сортировка по TIME: 

![TIME sort](/images/part9.7.png "Сортировка по TIME")

* Отфильтрованные по "sshd" (F4):

![sshd filter](/images/part9.8.png "Отфильтрованные по sshd")

* C процессом syslog, найденным, используя поиск (F3):

![syslog](/images/part9.9.png "C процессом syslog")

* C добавленным выводом hostname, clock и uptime:

![hostname, clock, uptime](/images/part9.10.png "C C добавленным выводом hostname, clock и uptime")

## Part 10. Использование утилиты fdisk
* Используем команду `sudo fdisk -l`:

![fdisk](/images/part10.1.png "Использование утилиты fdisk")

* Название жесткого диска - /dev/sda;
* Размер - 8 Gb;
* Количество секторов - 16777216;
* Размер swap - 0;

## Part 11. Использование утилиты df
* Запустим команду `df`:

![df](/images/part11.1.png "df")

* Для корневого раздела: 
1. Размер = 6352332 КB (килобайты);
2. Размер занятого пространства = 2733908 КB;
3. Размер свободного пространства = 3274568 KB;
4. Процент использования = 46%.

* Запустим команду `df -Th`:

![df -Th](/images/part11.2.png "df -Th")

* Для корневого раздела: 
1. Размер = 6,1 G;
2. Размер занятого пространства = 2,7 G;
3. Размер свободного пространства = 3,2 G;
4. Процент использования = 46%;
5. Тип файловой системы = ext4.

## Part 12. Использование утилиты du
> -b - Выдавать размеры в байтах вместо килобайтов.

> -h, --human-readable - Показывать единицы измерения.

> -s, --summarize - Выдавать только суммарный итог для каждого аргумента.

> /home -  это личный каталог пользователя в операционной системе, где находятся его данные, настройки и т. д.

> /var - каталог, содержащий файлы, которые подвергаются наиболее частому изменению (от англ. variable — переменный) и этот каталог имеет тенденцию к увеличению.

> /var/log - файлы системных журналов

* Размер папок /home, /var, /var/log в байтах: 

![size in bytes](/images/part12.1.png "Размер папок в байтах")

* Размер папок /home, /var, /var/log в человекочитаемом виде: 

![human readable size](/images/part12.2.png "Размер папок с указанием единиц измерения")

* Чтобы вывести размер всего содержимого папки /var/log используем команду `sudo du -h /var/log/*`:

![var/log/* size](/images/part12.3.png "Размер содержимого папки /var/log")

## Part 13. Установка и использование утилиты ncdu
* Устанавливаем утилиту командой `sudo apt install ncdu`:

![install ncdu](/images/part13.1.png "Установка ncdu")

* Размер папок /home, /var: 

![size /home, /var](/images/part13.2.png "Размер папок /home, /var")

* Размер папки /var/log: 

![size /var/log](/images/part13.3.png "Размер папки /var/log")

## Part 14. Работа с системными журналами
> **/var/log/syslog или /var/log/messages** содержит глобальный системный журнал, в котором пишутся сообщения с момента запуска системы, от ядра Linux, различных служб, обнаруженных устройствах, сетевых интерфейсов и много другого.

> **/var/log/auth.log или /var/log/secure** — информация об авторизации пользователей, включая удачные и неудачные попытки входа в систему, а также задействованные механизмы аутентификации.

> **/var/log/dmesg** — драйвера устройств. Одноименной командой можно просмотреть вывод содержимого файла. Размер журнала ограничен, когда файл достигнет своего предела, старые сообщения будут перезаписаны более новыми. Задав ключ --level= можно отфильтровать вывод по критерию значимости.

* Вводим команду `tail /var/log/auth.log`:
* Время последней авторизации: 11:24:47;
* Имя пользователя new_user.

![auth info](/images/part14.1.png "Информация об авторизациях")

* Перезапустим службу sshd командой `sudo service sshd restart`. Записи в журнале /var/log/syslog:

![syslog](/images/part14.2.png "syslog")

## Part 15. Использование планировщика заданий CRON
> **CRON** - это программа-демон. Её основная задача выполнять указанные пользователем процессы в указанное пользователем время, например с определённой периодичностью.

> **uptime** - команда, отображающая время работы системы

* Создадим файл расписания для текущего пользователя командой `crontab -e` -> 5(nano) и вписываем команду `*/2 * * * * uptime'. Она будет вызывть команду uptime каждые две минуты:

![cron uptime](/images/part15.1.png "Запуск uptime с помощью CRON")

* Журнал с записями о выполнении команд:
![cron syslog](/images/part15.2.png "Журнал с записями о выполнении команд")

* Список текущих заданий CRON `crontab -l`:

![crontab -l](/images/part15.3.png "Список текущих заданий CRON")

* Список текущих заданий CRON после удаления `crontab -r`:

![crontab -l after del](/images/part15.4.png "Список текущих заданий CRON после удаления")
